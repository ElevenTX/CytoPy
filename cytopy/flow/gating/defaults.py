from mongoengine.base.datastructures import BaseList
import numpy as np
import mongoengine


class ChildConstructError(Exception):
    pass


class Geom(dict):
    """
    Geometric object defining a population e.g. a threshold or rectangular gate

    Parameters
    -----------
    shape: str
        Shape of the geometric object, must be one of ['ellipse', 'rect', 'threshold', '2d_threshold', 'poly', 'sml',
        'sub']
    x: str
        Name of the x-axis plane
    y: str, optional
        Name of the y-axis plane
    kwargs:
        Any additional keyword arguments
    """
    def __init__(self,
                 shape: str,
                 x: str,
                 y: str or None = None,
                 **kwargs):
        super().__init__()
        try:
            assert shape in ['ellipse', 'rect', 'threshold', '2d_threshold', 'poly', 'sml', 'sub']
            self.shape = shape
        except AssertionError:
            print('Invalid shape, must be one of: ellipse, rect, threshold, 2d_threshold', 'poly')
        self.x = x
        self.y = y
        for k, v in kwargs.items():
            self[k] = v

    def as_dict(self) -> dict:
        """
        Converts object to base class (Python dictionary)

        Returns
        -------
        dict
        """
        self.update({'shape': self.shape, 'x': self.x, 'y': self.y})
        return self


class ChildPopulation:
    def __init__(self,
                 gate_type: str,
                 **kwargs):
        """
        Representation of a single population that is to be stored in a ChildPopulationCollection. Contains the state
        of a population being generated by some gating operation.

        Parameters
        -----------
        gate_type: str
            Type of gate that generates the population
        kwargs:
            Additional keyword arguments for generating population
        """
        self.gate_type = gate_type
        x = self._validate_input(gate_type, **kwargs)
        if x is False:
            raise ChildConstructError('Aborting; invalid child population construct')
        self.index = np.array([])
        self.geom = None

    def update_index(self,
                     idx: np.array,
                     merge_options: str = 'merge') -> None:
        """
        Update the index values of this population

        Parameters
        -----------
        idx: Numpy.array
            index values corresponding to events data
        merge_options: str
            how to handle existing data; either overwrite or merge

        Returns
        --------
        None
        """
        if merge_options == 'overwrite':
            self.index = np.array(idx, dtype=np.int)
        elif merge_options == 'merge':
            self.index = np.array(np.unique(np.concatenate((self.index, idx))), dtype=np.int)
        else:
            print('Invalid input for merge_options, must be one of: merge, overwrite')

    def update_geom(self,
                    x: str or None,
                    shape: str or None = None,
                    y: str or None = None,
                    **kwargs):
        """
        Update geom associated to this child population instance

        Parameters
        -----------

        shape: str, optional
            type of shape generated, must be one of ['ellipse', 'rect', 'threshold', '2d_threshold', 'poly', 'sml',
            'sub']
        x: str
            name of x-axis plane
        y: str, optional
            name of y-axis plane
        kwargs:
            Other parameters that describe this geometric object

        Returns
        --------
        None
        """
        self.geom = Geom(shape, x, y, **kwargs)

    def _validate_input(self,
                        gate_type: str,
                        **kwargs) -> bool:
        """
        Internal function. Called on init to validate input for child population definition. If valid, kwargs will
        population the properties attribute of this child population. If invalid an ChildConstructError will be
        generated.

        gate_type: str
            the gate type of the intended gate to generate this child population. Must be one of:
            'threshold', 'threshold_2d', 'cluster', 'geom'.
        kwargs:
            arguments for population definition

        Returns
        --------
        bool
            True if valid else False
        """
        try:
            if gate_type == 'threshold_1d' or gate_type == 'geom':
                if not kwargs.keys() == {'definition', 'name'}:
                    raise ChildConstructError(f'For a threshold_1d gate child population must'
                                              f' be defined with keys `definition` and `name`; {kwargs.keys()} '
                                              f'provided')
                if not kwargs['definition'] in ['-', '+']:
                    raise ChildConstructError(f'For a threshold_1d `definition` must be one of [+, -]'
                                              f' not {kwargs["definition"]}')
            if gate_type == 'threshold_2d':
                if not kwargs.keys() == {'definition', 'name'}:
                    raise ChildConstructError(f'For a threshold_2d gate child population must'
                                              f' be defined with keys `definition` and `name`; {kwargs.keys()} '
                                              f'provided')
                if type(kwargs['definition']) == list or \
                        type(kwargs['definition']) == mongoengine.base.datastructures.BaseList:
                    for x in kwargs['definition']:
                        if x not in ['++', '--', '-+', '+-']:
                            raise ChildConstructError(f'Invalid definition {x}, must be one of '
                                                      f'[++, --, -+, +-]')
                else:
                    if not kwargs['definition'] in ['++', '--', '-+', '+-']:
                        raise ChildConstructError(f'Invalid definition {kwargs["definition"]}, must be '
                                                  f'one of [++, --, -+, +-]')
            if gate_type == 'cluster':
                if not kwargs.keys() == {'target', 'weight', 'name'}:
                    ChildConstructError(f'For cluster gating child population must contain keys [target, weight, '
                                        f'name]; {kwargs.keys()} provided')
                if len(kwargs['target']) != 2:
                    ChildConstructError('Invalid target provided for child population, must be a tuple or list '
                                        f'of length two, not {kwargs["target"]}')
                if not all([isinstance(x, int) or isinstance(x, float) for x in kwargs['target']]):
                    ChildConstructError('Invalid data type for target provided for child population, must be list '
                                        f'or tuple of floats or integers not {kwargs["target"]}')
                if not isinstance(kwargs['weight'], int):
                    ChildConstructError('Invalid data type provided for weight of child population, must be '
                                        f'of type Integer not {kwargs["weight"]}')
        except ChildConstructError as e:
            print(e)
            return False
        self.properties = kwargs
        return True


class ChildPopulationCollection:
    """
    Collection of child populations. This is the standard input handed to the Gate object prior to gating. It defines
    the expected output of the operation.

    Parameters
    -----------
    gate_type: str, optional
        the gate type of the intended gate to generate this child population. Must be one of:
        ['threshold_1d', 'threshold_2d', 'cluster', 'geom', 'sml', 'sub', 'merge', None]
    json_dict: dict
        dictionary to populate ChildPopulationCollection
    """
    def __init__(self,
                 gate_type=None,
                 json_dict=None):
        self.populations = dict()
        if json_dict is not None:
            self.deserialise(json_dict)
        else:
            valid = ['threshold_1d', 'threshold_2d', 'cluster', 'geom', 'sml', 'sub', 'merge', None]
            try:
                assert gate_type in valid
                self.gate_type = gate_type
            except AssertionError:
                print(f'Invalid gate type, must be one of: {valid}')

    def serialise(self) -> dict:
        """
        Using the current properties and the populations, creates a dictionary representation
        of population data

        Returns
        -------
        dict
        """
        serialised = dict(gate_type=self.gate_type, populations=list())
        for pop in self.populations.keys():
            serialised['populations'].append(self.populations[pop].properties)
        return serialised

    def deserialise(self,
                    json_dict: dict) -> None:
        """
        Given some dictionary representation of a ChildPopulationCollection, populate the object
        with properties and populations.

        Parameters
        ----------
        json_dict: dict

        Returns
        -------
        None
        """
        self.gate_type = json_dict['gate_type']
        for pop in json_dict['populations']:
            name = pop.pop('name')
            self.add_population(name=name, **pop)

    def add_population(self,
                       name: str,
                       **kwargs) -> None:
        """
        Add a new population to this collection

        Parameters
        -----------
        name: str
            name of the population
        kwargs:
            arguments for population definition. Will differ depending on gate type:
            threshold_1d:
                - definition: one of ['+', '-']. Defines how the population is identified in
                respect to the gate's resulting threshold(s)
            threshold_2d:
                - definition: one or more of ['++', '--', '-+', '-+']. Defines how the population is identified in
                respect to the gate's resulting threshold(s)
            cluster:
                - target: 2d coordinate of expected population medoid
                - weight: integer value for populations ranked priority (used in case of merged populations)
            geom:
                - definition: one of ['+', '-']. Defines how the population is identified in respect
                to the gate's resulting geom
        :return: None
        """
        if name in self.populations.keys():
            print(f'Error: a population with name {name} has already been associated to this '
                  f'ChildPopulationCollection')
            return None
        if self.gate_type == 'threshold_1d' or self.gate_type == 'threshold_2d':
            try:
                current_definitions = list()
                for _, d in self.populations.items():
                    if type(d.properties['definition']) == list:
                        current_definitions = current_definitions + d.properties['definition']
                    else:
                        current_definitions.append(d.properties['definition'])
                if any([kwargs['definition'] == x for x in current_definitions]):
                    print(f"Error: definition {kwargs['definition']} has already been assigned to a population "
                          f"in this collection")
            except KeyError:
                print(f'Invalid input for child population construction for gate type {self.gate_type}')
        self.populations[name] = ChildPopulation(name=name, gate_type=self.gate_type, **kwargs)

    def remove_population(self, name: str) -> None:
        """
        Remove population from collection

        Parameters
        ----------
        name: str
            name of population to remove

        Returns
        --------
        None
        """
        if name not in self.populations.keys():
            print(f'Error: population {name} does not exist')
        self.populations.pop(name)

    def fetch_by_definition(self,
                            definition: str):
        """
        Given a population definition e.g. '+' or ['++', '+-'] return the name of the corresponding population

        Parameters
        ----------
        definition: str
            population definition e.g. '+' or ['++', '+-']

        Returns
        -------
        str
        """
        for name, d in self.populations.items():
            if type(d.properties['definition']) == list or type(d.properties['definition']) == BaseList:
                if definition in d.properties['definition']:
                    return name
            else:
                if definition == d.properties['definition']:
                    return name
        return None

